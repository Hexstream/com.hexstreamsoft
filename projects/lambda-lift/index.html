<html>
  <head><title>lambda-lift</title>
    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1783234-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    <script src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </head>
  <body>
    <p><a href="/">HexstreamSoft</a></p>
    
    <p><b>30 september 2012: lambda-lift has been superseded by <a href="http://www.hexstreamsoft.com/projects/positional-lambda/">positional-lambda</a>. Use that instead.</b></p>

    <p><i>It seems this project <a href="http://www.reddit.com/r/lisp/comments/zr3xq/new_library_lambdalift_is_a_concise_intuitive_and/c67c005">will be renamed "positional-lambda"</a> after all.</i></p>

    <p><i>13 september 2012: I will fix the following issues <a href="http://www.reddit.com/r/lisp/comments/zr3xq/new_library_lambdalift_is_a_concise_intuitive_and/">thanks to community feedback on reddit</a>: Bad name, verbose &amp;rest, paucity of examples, bogus replacements in <code>'(:1 :2)</code>, absence of formal semantics description. I will also support nested <code>plambda</code> (formerly <code>lift</code>) since there's not really any good reason not to and it can be useful.</i></p>

    <p>lambda-lift is a concise, intuitive and flexible syntax for trivial lambdas that eschews explicit (and often contextually-redundant) naming of parameter variables in favor of positional references, with support for a used or ignored &amp;rest parameter and automatic declaration of ignored parameters when logical "gaps" are left in the positional references. Also, its :let "local special operator" allows one to "lift" parts of its body outside the lambda to a LET without needing to name and then refer to an explicit variable.</p>
    
    <p>LIFT is particularly useful when used in conjunction with mapping operators such as MAPCAR, though for brevity the mapping parts will not be shown in these examples, only the LIFT expressions and equivalent LAMBDA's.</p>

<pre>(lift (values :3 :1))
==
(lambda (first second third)
  (declare (ignore second))
  (values third first))

(lift &amp;rest rest (list* :2 :1 rest))
==
(lambda (first second &amp;rest rest)
  (list* second first rest))

(lift &amp;rest nil (list :2 :1))
==
(lambda (first second &rest rest)
  (declare (ignore rest))
  (list second first))
</pre>

<p>It's possible to specify a minimum number of required arguments:
<pre>(lift :3 :2)
==
(lambda (first second third)
  (declare (ignore first third))
  second)

(lift :2 :3) ; redundant minimum: 3 > 2.
==
(lift :3)</pre></p>

<p>Which also has the effect of "pushing back" the &amp;rest argument if there's one:
<pre>(lift :3 &amp;rest rest (mapcar :1 rest))
==
(lambda (first second third &amp;rest rest)
  (declare (ignore second third))
  (mapcar first rest))</pre></p>

<p>The first argument to LIFT is treated as a specification of the minimum number of arguments only if it looks like a positional reference and LIFT was invoked with other arguments:
<pre>(lift :2)
==
(lambda (first second)
  (declare (ignore first))
  second)</pre></p>

<p>LIFT accepts an implicit PROGN, not just one expression:
<pre>(lift (print :1) :2)
==
(lambda (first second)
  (print first)
  second)</pre></p>

<p>Also, LIFT's :let "local special operator" allows one to "lift" parts of its body outside the lambda to a LET without needing to name and then refer to an explicit variable.
  <pre>(lift :2 (list :1 (:let (random))))
==
(let ((number (random)))
  (lambda (first second)
    (declare (ignore second))
    (list first number)))</pre></p>

<p>Another feature is :once, which is like :let except it computes the associated form in its original lexical and dynamic context within the lambda the first time its evaluation completes and returns the cached value on subsequent evaluations.
  <pre>(lift (write :1 :base (:once *print-base*)))
==
(let (base basep)
  (lambda (first)
    (write first :base (if basep
                           base
                           (prog1 (setf base *print-base*)
                             (setf basep t))))))</pre></p>

<p>It is an error to nest the :let and :once local special operators
within themselves or eachother:
  <pre>(lift (:let (:let 1))) ; error</pre></p>

<p>Beware that LIFT's parsing model, described below, can result in
"false matches" for :let and :once:
  <pre>(lift (member :1 '(:let :let*))) ; won't do the right thing.

(lift (member :1 '(:let* :let))) ; will do the right thing.</pre></p>

<p>It would be possible to disable matching of :let and :some in quoted expressions, but this could theoretically adversely affect the semantics of some macros and leave other kinds of false matches anyway, so simplicity was chosen.</p>

<p>To use lambda-lift, simply (:import-from #:lambda-lift #:lift) from
your DEFPACKAGE. Don't (:use #:lambda-lift)! "Clashy" symbols might be
added to the lambda-lift package in the future.</p>

<p>lambda-lift should only be used to describe actually trivial lambdas, usually no more than 3 lines long, and should not be used in code returned by macros, because of "capture" issues. In particular, due to the LIFT macro's parsing model, it's not safe to nest multiple invocations.</p>

<p>However, these are not practical limitations since as LIFT expressions get bigger, the benefits of conciseness quickly fade out to be replaced by the problems of implicitness, so hopefully one wouldn't be tempted to use it in these scenarios anyway. The implicitness is not a problem for suitably short LIFT expressions since the surrounding context provides enough contextual information, and explicitly naming variables would then simply provide redundant information.</p>

<p>LIFT's deliberately simplistic "surface parsing" (and replacement) strategy is conceptually and implementationally simple and robust, as opposed to often-brittle "code-walking" where an attempt is made to take into account the actual semantics of forms and operators, often necessitating explicit support when new operators are introduced.</p>

<p>lambda-lift is so-named because it "lifts trivial expressions to a lambda", and also because of the behavior of its :let "local special operator" (described above).</p>

<p><b>To use lambda-lift, simply (:import-from #:lambda-lift #:lift). Don't (:use)!</b></p>

<p><b><code>(ql:quickload "lambda-lift")</code></b> (September 2012 quicklisp dist (or later) required, run <code>(ql:update-dist "quicklisp")</code> first if necessary.)</p>

    <p><a href="http://github.com/Hexstream/lambda-lift">The source code for lambda-lift is hosted on GitHub.</a></p>
    <p><a href="https://github.com/Hexstream/lambda-lift/blob/master/UNLICENSE">lambda-lift is in the Public Domain.</a><br />Do anything you want with it.</p>
    <h1><a href="lambda-lift_latest.tar.gz">Download latest lambda-lift.</a></h1>
    <p><i>Version 1.0 released 7 september 2012.</i></p>

    <blockquote class="twitter-tweet tw-align-center"><p>New library: lambda-lift is a concise, intuitive and flexible syntax for trivial lambdas that uses positional arg refs. <a href="http://t.co/HQW0KAEd" title="http://www.hexstreamsoft.com/projects/lambda-lift/">hexstreamsoft.com/projects/</a></p>&mdash; Jean-PhilippeParadis (@HexstreamSoft) <a href="https://twitter.com/HexstreamSoft/status/243993471529148416" data-datetime="2012-09-07T08:45:51+00:00">September 7, 2012</a></blockquote>
  </body>
</html>
