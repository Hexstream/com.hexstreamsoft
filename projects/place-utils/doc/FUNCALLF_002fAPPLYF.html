<html lang="en">
<head>
<title>FUNCALLF/APPLYF - Place-utils Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Place-utils Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Reference.html#Reference" title="Reference">
<link rel="prev" href="BULKF.html#BULKF" title="BULKF">
<link rel="next" href="CACHEF.html#CACHEF" title="CACHEF">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents place-utils, which is a Common Lisp library that
provides a few utilities relating to setfable places.

The project's home is `http://www.hexstreamsoft.com/projects/place-utils'.

Originally authored by Jean-Philippe Paradis <hexstream@gmail.com>.

This project is in the public domain.
See the Unlicense appendix for details.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="FUNCALLF%2fAPPLYF"></a>
<a name="FUNCALLF_002fAPPLYF"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="CACHEF.html#CACHEF">CACHEF</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="BULKF.html#BULKF">BULKF</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Reference.html#Reference">Reference</a>
<hr>
</div>

<h3 class="section">1.6 <code>funcallf</code>/<code>applyf</code></h3>

<div class="defun">
&mdash; Modify Macro: <b>funcallf</b><var> function-form place &amp;rest other-arg-forms &rArr; results<a name="index-funcallf-5"></a></var><br>
<blockquote><p><code>funcallf</code> updates a place by calling a function with the old
value of the place as first argument, possibly along with other
arguments. The result of the function is stored into the
place. Specifically:

          <ol type=1 start=1>
<li>Evaluate <var>function-form</var> to produce <var>function</var>;
<li>Evaluate the subforms of <var>place</var>, then read the primary value of
<var>place</var> to produce <var>old-place-value</var>;
<li>Evaluate each <var>other-arg-form</var> normally to produce
<var>other-arg</var>;
<li>Store into the <var>place</var> the primary value returned by calling
<var>function</var> with <var>old-place-value</var> and <var>other-args</var> as
arguments. If <var>place</var> has more than one store variable, the
remaining such variables are bound to <code>nil</code> prior to evaluation
of the storing form.
             </ol>
</p></blockquote></div>

<div class="defun">
&mdash; Modify Macro: <b>applyf</b><var> function place &amp;rest other-args &rArr; results<a name="index-applyf-6"></a></var><br>
<blockquote><p>Same as <code>funcallf</code> except <code>apply</code> is used to call the
<var>function</var> with the primary value of <var>place</var> and other-args. 
</p></blockquote></div>

<!-- @node PROXYF -->
<!-- @section @code{proxyf} -->
<!-- @deffn {Accessor Modifier} proxyf (&key around-subform before-subform after-subform@ -->
<!-- around-write before-write after-write@ -->
<!-- around-read before-read after-read) place -->
<!-- @code{proxyf} allows customization of a @var{place} by adding to or -->
<!-- replacing the normal behavior of value forms, the storing form or the -->
<!-- accessing form (here called ``subforms'', ``writer'' and ``reader'', -->
<!-- respectively). -->
<!-- This customization is made by specifying ``customizers'' (functions) -->
<!-- with the keyword arguments. As might be inferred from their names, the -->
<!-- way of combining these customizers to produce an effective form for -->
<!-- each of subform, writer and reader is inspired by standard method -->
<!-- combination. -->
<!-- @uref{http://www.lispworks.com/documentation/HyperSpec/Body/07_ffb.htm, -->
<!-- CLHS 7.6.6.2 Standard Method Combination} -->
<!-- The normal behavior of @var{place} for each of subforms, writer and -->
<!-- reader form the 3 ``primary methods''. If a key argument is specified -->
<!-- multiple times, all the specified customizers will be combined -->
<!-- appropriately as in standard method combination. Around, before and -->
<!-- after customizers specified earlier in the @code{proxyf} call are -->
<!-- deemed ``more specific'' than later ones. -->
<!-- Since it's known at compile-time what types of customizers are -->
<!-- supplied and in what order, the resulting setf-expansion should be -->
<!-- about as efficient as if you'd have written an equivalent accessor -->
<!-- modifier by hand. -->
<!-- @end deffn -->
<!-- @defun call-next-customizer &rest args -->
<!-- This function can be called from within the dynamic context of an -->
<!-- around specializer and has behavior analogous to -->
<!-- @code{call-next-method} for standard around methods. If called with no -->
<!-- arguments, the arguments that were used to call the current around -->
<!-- customizer are used to call the next customizer. -->
<!-- Note that unlike @code{call-next-method}, @code{call-next-customizer} -->
<!-- is a global function. This is to eliminate the requirement of an -->
<!-- explicit lambda if @code{call-next-customizer} needs to be -->
<!-- called. @code{call-next-customizer} relies on dynamic context that is -->
<!-- established only at the time around customizers are called. The -->
<!-- consequences are undefined if @code{call-next-customizer} is called -->
<!-- outside of this context. -->
<!-- @end defun -->
   </body></html>

